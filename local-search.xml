<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>限流算法笔记</title>
    <link href="/2023/11/25/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/11/25/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>令牌桶算法 <strong>Token Bucket Algorithm</strong> </p><p>基本内容：</p><ul><li>每 $$1&#x2F;r$$ 秒向桶中放入一个令牌 <strong>token</strong></li><li>桶的容量定义为最多持有 $$b$$ 个 <strong>token</strong>，当一个 <strong>token</strong> 在桶容量满时到达，这个 <strong>token</strong> 会被丢弃</li><li>当一个 $$n$$ bytes 的分组到达时，可能出现以下情况：</li><li>当桶中容量大于等于 $$n$$ 个 token ，从桶中移除 $$n$$ 个 <strong>token</strong> 并将分组发送</li><li>当桶中容量不足 $$n$$ 个 token，不从桶中移除 token ，该分组即为不合格分组 <strong>non-conformant</strong></li><li>平均速率 $$r$$</li><li>假设 $$M$$ 作为最大传输速率（bytes&#x2F;second），那么假设 $$r$$ &lt; $$M$$ ，有 $$T_{max}$$ &#x3D; $$b&#x2F;(M - r)$$ ，且最大突发传输量大小 $$B_{max}$$ &#x3D; $$T_{max}$$ ∗ $$M$$</li></ul><p>漏桶算法 <strong>Leaky Bucket Algorithm</strong></p><p>基本内容：</p><ul><li><strong>as a meter</strong> </li><li>固定容量的桶，以固定的速率泄露</li><li>当桶是空的时候，停止泄露</li><li>当判断一个分组是否符合要求时，要求该分组可以看作向桶中加入特定量的水，该量可以按整个分组长度定义或按照分组长度的一定比例进行定义</li><li>如果水的量超出了桶的容量，那么该分组 <strong>non-conformant</strong> 并且不改变桶内水量</li><li>该方法与令牌桶算法是镜像的，在实际效果方面一致。</li><li><strong>as a queue</strong></li><li>漏桶当作一个有限队列，当新的分组来临时，如果有空间就加入队列，否则丢弃</li><li>桶中流量只能以恒定速率流出（At every clock tick one packet is transmitted）</li><li>可以用来 <strong>traffic shaping</strong> 平滑流量，抵消峰值流量</li></ul><p><strong>参考</strong></p><p><a href="https://en.wikipedia.org/wiki/Token_bucket">https://en.wikipedia.org/wiki/Token_bucket</a></p><p><a href="https://en.wikipedia.org/wiki/Leaky_bucket">https://en.wikipedia.org/wiki/Leaky_bucket</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
